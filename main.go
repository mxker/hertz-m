// Code generated by hertz generator.

package main

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/server"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/hertz-contrib/http2/config"
	"github.com/hertz-contrib/http2/factory"
	hertztracing "github.com/hertz-contrib/obs-opentelemetry/tracing"
	"net/http"
	"os"
	"strconv"
	"time"
)

func main() {
	logFile, err := os.OpenFile("./output.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(err)
	}
	defer logFile.Close()
	hlog.SetOutput(logFile)

	tracer, cfg := hertztracing.NewServerTracer()

	h := server.Default(tracer,
		server.WithHostPorts("127.0.0.1:8800"),
	)

	h.Use(hertztracing.ServerMiddleware(cfg))

	hlog.Info("start")
	//h.POST("/h1", func(c context.Context, ctx *app.RequestContext) {
	//	defer TimeCost("h1")()
	//	var j map[string]string
	//	_ = json.Unmarshal(ctx.Request.Body(), &j)
	//	fmt.Printf("server çreceived request: %+v\n", j)
	//	r := map[string]string{
	//		"msg": "hello world",
	//	}
	//	for k, v := range j {
	//		r[k] = v
	//	}
	//
	//	for i := 1; i < 100000; i++ {
	//		r["i"] = strconv.Itoa(i)
	//	}
	//	ctx.JSON(http.StatusOK, r)
	//})7

	Register(h)

	// 优雅退出
	//h.SetCustomSignalWaiter(func(err chan error) error {
	//	return nil
	//})

	h.Spin()
	//h2()
	//h2c()
}

const (
	keyPEM  = `<your key PEM>`
	certPEM = `<your cert PEM>`
)

func h2() {
	cfg := &tls.Config{
		MinVersion:       tls.VersionTLS12,
		CurvePreferences: []tls.CurveID{tls.X25519, tls.CurveP256},
		CipherSuites: []uint16{
			tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
		},
	}

	cert, err := tls.X509KeyPair([]byte(certPEM), []byte(keyPEM))
	if err != nil {
		fmt.Printf("X509KeyPair err: %+v\n", err)
		return
	}
	cfg.Certificates = append(cfg.Certificates, cert)
	h := server.New(server.WithHostPorts(":8800"), server.WithALPN(true), server.WithTLS(cfg))
	h.AddProtocol("h2", factory.NewServerFactory(
		config.WithReadTimeout(time.Minute),
		config.WithDisableKeepAlive(false)))
	cfg.NextProtos = append(cfg.NextProtos, "h2")

	h.POST("/h2", func(ctx context.Context, c *app.RequestContext) {
		var req map[string]string
		err := json.Unmarshal(c.Request.Body(), &req)
		fmt.Printf("[server]: received request: %+v\n", req)
		if err != nil {
			fmt.Printf("Unmarshal request err: %+v\n", err)
			return
		}
		resp := map[string]string{
			"message": "success",
		}
		for k, v := range req {
			resp[k] = v
		}
		c.JSON(consts.StatusOK, resp)
	})
	h.Spin()
}

func h2c() {
	h := server.New(server.WithHostPorts(":8801"), server.WithH2C(true))
	h.AddProtocol("h2", factory.NewServerFactory())

	h.POST("/h2c", func(c context.Context, ctx *app.RequestContext) {
		defer TimeCost("h2c")()
		var j map[string]string
		_ = json.Unmarshal(ctx.Request.Body(), &j)
		fmt.Printf("server çreceived request: %+v\n", j)
		r := map[string]string{
			"msg": "hello world",
		}
		for k, v := range j {
			r[k] = v
		}

		for i := 1; i < 100000; i++ {
			r["i"] = strconv.Itoa(i)
		}
		ctx.JSON(http.StatusOK, r)
	})

	h.Spin()
}

// TimeCost 耗时统计
// 调用：defer util.TimeCost("get user")() 注意，是对 timeCost()返回的函数进行调用，因此需要加两对小括号
func TimeCost(desc string) func() {
	start := time.Now()
	return func() {
		tc := time.Since(start)
		fmt.Printf("%s time cost = %v\n", desc, tc)
	}
}
